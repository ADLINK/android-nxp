From 112b98d0887822abb5f126ba196e11fe01df3f01 Mon Sep 17 00:00:00 2001
From: Arun Kumar <arunkumar.ev@ltts.com>
Date: Sun, 9 Feb 2020 14:52:45 +0530
Subject: [PATCH 12/13] IMX8M: Ethent dp83867 pinctrl changes

Ethent dp83867 pinctrl changes and add tx rx internal delay

Signed-off-by: Arun Kumar <arunkumar.ev@ltts.com>
---
 arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts |  47 ++--
 arch/arm64/configs/android_defconfig            |   1 +
 drivers/net/phy/Kconfig                         |   7 +
 drivers/net/phy/dp83867.c                       | 313 ++++++++++++++++++++++++
 4 files changed, 349 insertions(+), 19 deletions(-)

diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
index aa39f32..425966e6 100644
--- a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
@@ -16,6 +16,7 @@
 /dts-v1/;
 
 #include "fsl-imx8mq.dtsi"
+#include <dt-bindings/net/ti-dp83867.h>
 
 / {
 	firmware {
@@ -147,16 +148,16 @@
 
 &iomuxc {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_hog>;
+	/*pinctrl-0 = <&pinctrl_hog>;*/
 
-	imx8mq-evk {
-		pinctrl_hog: hoggrp {
+	lec-imx8m {
+		/*pinctrl_hog: hoggrp {
 			fsl,pins = <
 				MX8MQ_IOMUXC_NAND_READY_B_GPIO3_IO16		0x19
 				MX8MQ_IOMUXC_NAND_WE_B_GPIO3_IO17		0x19
 				MX8MQ_IOMUXC_NAND_WP_B_GPIO3_IO18		0x19
 			>;
-		};
+		};*/
 
 		pinctrl_ir_recv: ir_recv {
 			fsl,pins = <
@@ -184,21 +185,24 @@
 
 		pinctrl_fec1: fec1grp {
 			fsl,pins = <
-				MX8MQ_IOMUXC_ENET_MDC_ENET1_MDC		0x3
-				MX8MQ_IOMUXC_ENET_MDIO_ENET1_MDIO	0x23
-				MX8MQ_IOMUXC_ENET_TD3_ENET1_RGMII_TD3	0x1f
-				MX8MQ_IOMUXC_ENET_TD2_ENET1_RGMII_TD2	0x1f
-				MX8MQ_IOMUXC_ENET_TD1_ENET1_RGMII_TD1	0x1f
-				MX8MQ_IOMUXC_ENET_TD0_ENET1_RGMII_TD0	0x1f
-				MX8MQ_IOMUXC_ENET_RD3_ENET1_RGMII_RD3	0x91
-				MX8MQ_IOMUXC_ENET_RD2_ENET1_RGMII_RD2	0x91
-				MX8MQ_IOMUXC_ENET_RD1_ENET1_RGMII_RD1	0x91
-				MX8MQ_IOMUXC_ENET_RD0_ENET1_RGMII_RD0	0x91
-				MX8MQ_IOMUXC_ENET_TXC_ENET1_RGMII_TXC	0x1f
-				MX8MQ_IOMUXC_ENET_RXC_ENET1_RGMII_RXC	0x91
+				MX8MQ_IOMUXC_ENET_MDC_ENET1_MDC			0x3
+				MX8MQ_IOMUXC_ENET_MDIO_ENET1_MDIO		0x23
+				MX8MQ_IOMUXC_ENET_TD3_ENET1_RGMII_TD3		0x1f
+				MX8MQ_IOMUXC_ENET_TD2_ENET1_RGMII_TD2		0x1f
+				MX8MQ_IOMUXC_ENET_TD1_ENET1_RGMII_TD1		0x1f
+				MX8MQ_IOMUXC_ENET_TD0_ENET1_RGMII_TD0		0x1f
+				MX8MQ_IOMUXC_ENET_RD3_ENET1_RGMII_RD3		0x91
+				MX8MQ_IOMUXC_ENET_RD2_ENET1_RGMII_RD2		0x91
+				MX8MQ_IOMUXC_ENET_RD1_ENET1_RGMII_RD1		0x91
+				MX8MQ_IOMUXC_ENET_RD0_ENET1_RGMII_RD0		0x91
+				MX8MQ_IOMUXC_ENET_TXC_ENET1_RGMII_TXC		0x1f
+				MX8MQ_IOMUXC_ENET_RXC_ENET1_RGMII_RXC		0x91
 				MX8MQ_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x91
 				MX8MQ_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x1f
-				MX8MQ_IOMUXC_GPIO1_IO09_GPIO1_IO9	0x19
+                                MX8MQ_IOMUXC_GPIO1_IO09_ENET1_1588_EVENT0_OUT   0x40
+                                MX8MQ_IOMUXC_GPIO1_IO08_ENET1_1588_EVENT0_IN    0x40
+                                MX8MQ_IOMUXC_NAND_WE_B_GPIO3_IO17               0x19
+                                MX8MQ_IOMUXC_NAND_WP_B_GPIO3_IO18               0x19
 			>;
 		};
 
@@ -429,6 +433,8 @@
 	pinctrl-0 = <&pinctrl_fec1>;
 	phy-mode = "rgmii-id";
 	phy-handle = <&ethphy0>;
+	phy-reset-gpios = <&gpio3 17 0>;
+	phy-reset-active-low;
 	fsl,magic-packet;
 	status = "okay";
 
@@ -439,8 +445,11 @@
 		ethphy0: ethernet-phy@0 {
 			compatible = "ethernet-phy-ieee802.3-c22";
 			reg = <0>;
-			at803x,led-act-blind-workaround;
-			at803x,eee-disabled;
+			interrupt-parent = <&gpio3>;
+			interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+			ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+			ti,tx-internal-delay = <DP83867_RGMIIDCTL_2_75_NS>;
+			ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
 		};
 	};
 };
diff --git a/arch/arm64/configs/android_defconfig b/arch/arm64/configs/android_defconfig
index c294d11..c0368153 100644
--- a/arch/arm64/configs/android_defconfig
+++ b/arch/arm64/configs/android_defconfig
@@ -1012,3 +1012,4 @@ CONFIG_CRYPTO_CHACHA20_NEON=m
 CONFIG_CRYPTO_AES_ARM64_BS=m
 CONFIG_GPIO_PCAL6416A=y
 CONFIG_GPIO_SX150X=y
+CONFIG_DP83867_PHY=y
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index d9b51a7..97c05ba 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -287,6 +287,13 @@ config DP83867_PHY
 	---help---
 	  Currently supports the DP83867 PHY.
 
+config DP83867_ETH_TEST
+	bool "Texas Instruments DP83867 Gigabit PHY Layer Compliance Tests"
+	default n
+	depends on DP83867_PHY
+	---help---
+	  Enable DP83867 to support 1000BASE-T/100BASE-TX/10BASE-T Physical Layer Compliance Tests.
+
 config FIXED_PHY
 	tristate "MDIO Bus/PHY emulation with fixed speed/link PHYs"
 	depends on PHYLIB
diff --git a/drivers/net/phy/dp83867.c b/drivers/net/phy/dp83867.c
index c1ab976..56e8904 100644
--- a/drivers/net/phy/dp83867.c
+++ b/drivers/net/phy/dp83867.c
@@ -22,6 +22,13 @@
 
 #include <dt-bindings/net/ti-dp83867.h>
 
+#if defined(CONFIG_DP83867_ETH_TEST)
+#include <linux/delay.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#endif
+
 #define DP83867_PHY_ID		0x2000a231
 #define DP83867_DEVADDR		0x1f
 
@@ -41,6 +48,12 @@
 #define DP83867_SW_RESET	BIT(15)
 #define DP83867_SW_RESTART	BIT(14)
 
+/* Extended LED Registers */
+#if defined(CONFIG_ARCH_LEC_IMX8M)
+#define DP83867_LEDCR1		0x0018
+#define DP83867_LEDCR2		0x0019
+#endif
+
 /* MICR Interrupt bits */
 #define MII_DP83867_MICR_AN_ERR_INT_EN		BIT(15)
 #define MII_DP83867_MICR_SPEED_CHNG_INT_EN	BIT(14)
@@ -94,6 +107,254 @@ struct dp83867_private {
 	bool rxctrl_strap_quirk;
 };
 
+#if defined(CONFIG_DP83867_ETH_TEST)
+static int pattern = 0;
+static int channel = 0;
+static bool init_fs = 0;
+struct phy_device* myDev = NULL;
+static int set_pattern(int type)
+{
+	int rd_val = 0;
+	int retval = -1;
+
+	switch(type) {
+	case 0: //Reset Phy
+		phy_write(myDev, 0x001F, 0x8000);
+		printk(KERN_INFO "Reset Phy\n");
+		break;
+	case 1: //1000 Base Test Mode 1
+		if (channel == 0) {
+			printk(KERN_INFO "1000 Base Test Mode 1: channel=0 will output all channel\n");
+			printk(KERN_INFO "You also can set channel=1-4 to only output 1 channel\n");
+		} else if (channel > 4) {
+			printk(KERN_INFO "1000 Base Test Mode 1 channel didn't set correctly\n");
+			break;
+		}
+
+		retval = phy_write(myDev, 0x001F, 0x8000);
+		if(retval < 0)
+			printk(KERN_INFO "0x001F write fail\n");
+		retval = phy_write(myDev, 0x0000, 0x0140);
+		if(retval < 0)
+			printk(KERN_INFO "0x0000 write fail\n");
+		retval = phy_write(myDev, 0x0010, 0x5008);
+		if(retval < 0)
+			printk(KERN_INFO "0x0010 write fail\n");
+		retval = phy_write(myDev, 0x0009, 0x3B00);
+		if(retval < 0)
+			printk(KERN_INFO "0x0009 write fail\n");
+		printk(KERN_INFO "1000 Base Test Mode 1, Channel=%d\n", channel);
+
+		rd_val = phy_read(myDev, 0x0000); printk(KERN_INFO "Read phyaddr 0x0000=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0010); printk(KERN_INFO "Read phyaddr 0x0010=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0009); printk(KERN_INFO "Read phyaddr 0x0009=0x%08x\n", rd_val);
+
+		switch(channel) {
+		case 0:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+			break;
+		case 1:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0400);
+			break;
+		case 2:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0420);
+			break;
+		case 3:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0440);
+			break;
+		case 4:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0460);
+			break;
+		default:
+			printk(KERN_INFO "\n1000 Base Test Mode 1 channel didn't set correctly\n");
+			break;
+		}
+
+		phy_write_mmd_indirect(myDev, 0x01D5, DP83867_DEVADDR, 0xF508);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR); printk(KERN_INFO "Channel=%d Read phyaddr 0x0025=0x%08x\n", channel, rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x01D5, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x01D5=0x%08x\n", rd_val);
+		break;
+	case 2: //1000 Base Test Mode 2
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x5B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "1000 Base Test Mode 2\n");
+		break;
+	case 3: //1000 Base Test Mode 2 with TX_TCLK
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x5B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		//phy_write(myDev, 0x0170, 0x081F);
+		//phy_write(myDev, 0x00C6, 0x0010);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0170, DP83867_DEVADDR, 0x081F);
+		phy_write_mmd_indirect(myDev, 0x00C6, DP83867_DEVADDR, 0x0010);
+		printk(KERN_INFO "1000 Base Test Mode 2 with TX_TCLK\n");
+		rd_val = phy_read(myDev, 0x0000); printk(KERN_INFO "Read phyaddr 0x0000=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0010); printk(KERN_INFO "Read phyaddr 0x0010=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0009); printk(KERN_INFO "Read phyaddr 0x0009=0x%08x\n", rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x0025=0x%08x\n", rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0170, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x0170=0x%08x\n", rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x00C6, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x00C6=0x%08x\n", rd_val);
+		break;
+	case 4: //1000 Base Test Mode 3
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x7B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "1000 Base Test Mode 3\n");
+		break;
+	case 5: //1000 Base Test Mode 3 with TX_TCLK
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x7B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		//phy_write(myDev, 0x0170, 0x081F);
+		//phy_write(myDev, 0x00C6, 0x0010);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0170, DP83867_DEVADDR, 0x081F);
+		phy_write_mmd_indirect(myDev, 0x00C6, DP83867_DEVADDR, 0x0010);
+		printk(KERN_INFO "1000 Base Test Mode 3 with TX_TCLK\n");
+		break;
+	case 6: //1000 Base Test Mode 4
+		if(channel == 0) {
+			printk(KERN_INFO "1000 Base Test Mode 4 channel has not been set\n");
+			break;
+		}
+
+		retval = phy_write(myDev, 0x001F, 0x8000);
+		if(retval < 0)
+			printk(KERN_INFO "0x001F write fail\n");
+		retval = phy_write(myDev, 0x0000, 0x0140);
+		if(retval < 0)
+			printk(KERN_INFO "0x0000 write fail\n");
+		retval = phy_write(myDev, 0x0010, 0x5008);
+		if(retval < 0)
+			printk(KERN_INFO "0x0010 write fail\n");
+		retval = phy_write(myDev, 0x0009, 0x9B00);
+		if(retval < 0)
+			printk(KERN_INFO "0x0009 write fail\n");
+		printk(KERN_INFO "1000 Base Test Mode 4, Channel=%d\n", channel);
+
+		rd_val = phy_read(myDev, 0x0000); printk(KERN_INFO "Read phyaddr 0x0000=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0010); printk(KERN_INFO "Read phyaddr 0x0010=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0009); printk(KERN_INFO "Read phyaddr 0x0009=0x%08x\n", rd_val);
+
+		switch(channel) {
+		case 1:
+			//retval = phy_write(myDev, 0x0025, 0x0400);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0400);
+			break;
+		case 2:
+			//retval = phy_write(myDev, 0x0025, 0x0420);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0420);
+			break;
+		case 3:
+			//retval = phy_write(myDev, 0x0025, 0x0440);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0440);
+			break;
+		case 4:
+			//retval = phy_write(myDev, 0x0025, 0x0460);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0460);
+			break;
+		default:
+			printk(KERN_INFO "\n1000 Base Test Mode 4 channel has not been set\n");
+			break;
+		}
+		//if(retval < 0)
+		//	printk(KERN_INFO "0x0025 write fail\n");
+
+		//rd_val = phy_read(myDev, 0x0025); printk(KERN_INFO "Channel=%d Read phyaddr 0x0025=0x%08x\n", channel, rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR); printk(KERN_INFO "Channel=%d Read phyaddr 0x0025=0x%08x\n", channel, rd_val);
+		break;
+	case 7: //100 Base Standard MDI (Test Mode 5)
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0210);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0xBB00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "100 Base Standard MDI (Test Mode 5)\n");
+		break;
+	case 8: //100 Base Standard MDIX (Test Mode 5):
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x2100);
+		phy_write(myDev, 0x0010, 0x5028);
+		phy_write(myDev, 0x0009, 0xBB00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "100 Base Standard MDIX (Test Mode 5)\n");
+		break;
+	case 9: //10 Base Link Pulse
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0100);
+		phy_write(myDev, 0x0010, 0x5008);
+		printk(KERN_INFO "10 Base Link Pulse\n");
+		printk(KERN_INFO "pattern phyAddr->\n0x0000=0x%04x\n0x0010=0x%04x\n",\
+			phy_read(myDev, 0x0000),\
+			phy_read(myDev, 0x0010));
+		break;
+	case 10: //10 Base Standard
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x1000);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0016, 0x0020);
+		printk(KERN_INFO "10 Base Standard\n");
+		printk(KERN_INFO "pattern phyAddr->\n0x0000=0x%04x\n0x0010=0x%04x\n0x0016=0x%04x\n",\
+			phy_read(myDev, 0x0000),\
+			phy_read(myDev, 0x0010),\
+			phy_read(myDev, 0x0016));
+		break;
+	}
+	return 0;
+}
+
+static ssize_t pattern_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", pattern);
+}
+
+static ssize_t pattern_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	sscanf(buf, "%du", &pattern);
+	set_pattern(pattern);
+	return count;
+}
+
+static ssize_t channel_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", channel);
+}
+
+static ssize_t channel_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	sscanf(buf, "%du", &channel);
+	return count;
+}
+
+static struct kobject *test_pattern_kobj = NULL;
+static struct kobj_attribute pattern_attribute = __ATTR(pattern, 0600, pattern_show, pattern_store);
+static struct kobj_attribute channel_attribute = __ATTR(channel, 0600, channel_show, channel_store);
+
+static struct attribute *attrs[] = {
+        &pattern_attribute.attr,
+        &channel_attribute.attr,
+        NULL,
+};
+
+static struct attribute_group attr_group = {
+        .attrs = attrs,
+};
+#endif
+
 static int dp83867_ack_interrupt(struct phy_device *phydev)
 {
 	int err = phy_read(phydev, MII_DP83867_ISR);
@@ -204,6 +465,9 @@ static int dp83867_config_init(struct phy_device *phydev)
 	int ret, val, bs;
 	u16 delay;
 
+#if defined(CONFIG_DP83867_ETH_TEST)
+	int retval;
+#endif
 	if (!phydev->priv) {
 		dp83867 = devm_kzalloc(&phydev->mdio.dev, sizeof(*dp83867),
 				       GFP_KERNEL);
@@ -295,6 +559,55 @@ static int dp83867_config_init(struct phy_device *phydev)
 	if (dp83867->port_mirroring != DP83867_PORT_MIRROING_KEEP)
 		dp83867_config_port_mirroring(phydev);
 
+#if defined(CONFIG_ARCH_LEC_IMX8M)
+	/* LED Configuration for LEC-BASE 2.0 Board */
+	/* Set LED pins' function - set LED_0 1011, LED_1 0110, LED_2 0101, LED_GPIO 1111 */
+	/* LED_0    1011: Link established, blink for transmit or receive activity */
+	/* LED_1    0110: 100 BTX link established */
+	/* LED_2    0101: 1000BT link established */
+	/* LED_GPIO 1111: Reserved */
+	val = phy_read(phydev, DP83867_LEDCR1);
+	if (val < 0)
+		return val;
+
+	if ((val & 0xFFFF) != 0xF56B) {
+		val &= ~0xFFFF;
+		val |= 0xF56B;
+		ret = phy_write(phydev, DP83867_LEDCR1, val);
+		if (ret)
+			return ret;
+	}
+
+	/* Control LED outputs' ability - set LED_0, LED_1, LED_2 active low, LED_GPIO reserve */
+	val = phy_read(phydev, DP83867_LEDCR2);
+	if (val < 0)
+		return val;
+
+	if ((val & 0xFFFF) != 0x0000) {
+		val &= ~0xFFFF;
+		val |= 0x0000;
+		ret = phy_write(phydev, DP83867_LEDCR2, val);
+		if (ret)
+			return ret;
+	}
+#endif
+#if defined(CONFIG_DP83867_ETH_TEST)
+	// Enable PHY compliance test function.
+	if(!init_fs) {
+		test_pattern_kobj = kobject_create_and_add("phy_debug", kernel_kobj);
+		if (!test_pattern_kobj)
+			return -ENOMEM;
+
+	        /* Create the files associated with this kobject */
+	        retval = sysfs_create_group(test_pattern_kobj, &attr_group);
+		if (retval) {
+			kobject_put(test_pattern_kobj);
+			printk(KERN_INFO "%s=>crate sysfs fail...\n", __func__);
+		}
+		init_fs = 1;
+	}
+	myDev = phydev;
+#endif
 	return 0;
 }
 
-- 
2.7.4

